<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Clojure Blog</title>
    <description>Блог о Clojure и других технологиях, связанных на Lisp.</description>
    <link>http://clojure.by/</link>
    <atom:link href="http://clojure.by/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 09 Jul 2016 23:27:15 +0300</pubDate>
    <lastBuildDate>Sat, 09 Jul 2016 23:27:15 +0300</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>Почему после двух лет Haskell я снова вернулся к Clojure</title>
        <description>&lt;h3 id=&quot;haskell&quot;&gt;Как я попал в Haskell&lt;/h3&gt;

&lt;p&gt;В процессе изучения Clojure еще в конце 2009-го года я стал всё чаще встречать упоминания о Haskell. В Clojure пришли хаскелисты и притащили туда монады, монадические комбинаторы парсеров, идею о борьбе с NPE через тип Maybe и многое другое. Упоминали также, что и сам Clojure подвергся очень сильному влиянию Haskell: все эти персистентные структуры данных, транзакционная память и, наверняка, многое другое позаимствовали в Haskell. Мне стало интересно, и я решил докопаться до истоков.&lt;/p&gt;

&lt;p&gt;Оказалось, что, действительно, Haskell – очень мощный язык, программы на котором выглядят потрясающе красиво. Более того – Haskell затягивает. Одного лишь изучения языка становится мало, хочется понять, на каких принципах он основан. Даже беглое ознакомление с теорией категорий приводит к мысли, что Haskell – это просто способ записать на компьютере утверждения из математики, а программа на Haskell – это &lt;em&gt;одна большая формула&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Однако уже на этапе просто ознакомления с языком стали появляться проблемы, которым я, впрочем, не придал тогда большого значения. Изучение Haskell шло медленно. Тогда еще не было отличного &lt;a href=&quot;https://stepic.org/course/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BD%D0%B0-%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5-Haskell-75/syllabus&quot;&gt;курса&lt;/a&gt; Дениса Москвина, в деталях объясняющего много тонкостей. Не было потрясающе понятной книжки &lt;a href=&quot;http://haskellbook.com/&quot;&gt;HaskellBook&lt;/a&gt;, подробно разжевывающей сложные определения. Не было даже ориентированной на практику &lt;a href=&quot;http://www.ozon.ru/context/detail/id/35161141/&quot;&gt;Изучаем Haskell&lt;/a&gt; Алехандро Серано Мена. А то, что &lt;a href=&quot;http://www.ozon.ru/context/detail/id/24811492/&quot;&gt;было&lt;/a&gt;, &lt;a href=&quot;http://book.realworldhaskell.org/&quot;&gt;добавляло&lt;/a&gt; больше вопросов, чем ответов.&lt;/p&gt;

&lt;p&gt;Честно говоря, сейчас, по прошествии нескольких лет, я всё так же считаю, что &lt;em&gt;изучать&lt;/em&gt; Haskell – довольно сложно, даже несмотря на появление более качественных и доступных материалов.&lt;/p&gt;

&lt;p&gt;В результате я решил, что моё поверхностное знакомство с Haskell длится слишком долго. Пора разобраться с Haskell основательно: нужно или сделать его одним из своих инструментов, или полностью отказаться от него.&lt;/p&gt;

&lt;p&gt;В 2014-м я выделил действительно много времени на изучение языка, а весь 2015-й и часть 2016-го – практиковался. Помимо множества хобби-проектов, вроде &lt;a href=&quot;https://github.com/dbushenko/trurl&quot;&gt;кодогенератора trurl&lt;/a&gt;, я написал и запустил во “внутренний” продакшен два single-page веб-приложения, где backend был полностью на Haskell, а frontend – на PureScript. Я это к тому, что все проблемы, которые я выявил при использовании Haskell, прошли через вот этот, пусть небольшой, но всё же опыт использования Haskell в реальных проектах.&lt;/p&gt;

&lt;h3 id=&quot;c-----&quot;&gt;C чем я столкнулся на практике&lt;/h3&gt;

&lt;p&gt;Во время разработки двух внутренних проектов на Haskell я столкнулся с несколькими странностями, которые, на мой взгляд, здорово мешают использовать Haskell на реальных задачах. Здесь я хотел бы подчеркнуть, что мои задачи – это вовсе не разработка компиляторов или каких-то наукоёмких технологий. Всё проще: я делаю веб-сервисы и веб-приложения.&lt;/p&gt;

&lt;h5 id=&quot;haskell--&quot;&gt;Haskell сложно отлаживать&lt;/h5&gt;

&lt;p&gt;К сожалению – это всё-таки имеет значение. Самый обычный дебаггер с самыми обычными брейкпоинтами в самом деле могут помочь &lt;em&gt;быстро&lt;/em&gt; решить проблему. Если у вас Java или C#, но никак не Haskell. Теоретически, брейкпоинты можно использовать и в Haskell, но это настолько сложно, что на практике вы будете использовать просто вывод в консоль при помощи &lt;em&gt;trace&lt;/em&gt; или &lt;em&gt;traceShow&lt;/em&gt;. Дело в том, что в Haskell программа – это длинная формула, да еще и ленивая. Иногда вам просто некуда будет этот брейкпоинт поставить!&lt;/p&gt;

&lt;p&gt;А вторая проблема отладки – сложность контекстов. Это всё в теории выглядит хорошо – чистые функции, красивые типы. А на практике у вас будет гораздо чаще монада, завёрнутая в несколько слоёв монадических преобразователей, и понять где там что – та ещё задача. Там даже &lt;em&gt;trace&lt;/em&gt; влепить некуда, так что приходится полагаться в основном на юнит-тесты, которые, кстати, в таких сложных контекстах писать тоже сложно.&lt;/p&gt;

&lt;h5 id=&quot;haskell------&quot;&gt;В Haskell нет нормального стека для веб-разработки&lt;/h5&gt;

&lt;p&gt;Тут я, конечно, рискую словить пару тухлых помидоров от любителей &lt;a href=&quot;http://www.yesodweb.com/&quot;&gt;Yesod&lt;/a&gt; или &lt;a href=&quot;haskell-servant.github.io/&quot;&gt;Servant&lt;/a&gt;, но всё же дайте мне пояснить мою позицию. Я, как инженер, терпеть не могу всякую “черную магию”. Если я не понимаю технологию или инструмент, то сам, по своей воле, ни за что его не выберу. Если я вынужден использовать фреймворк, в котором я не разбираюсь или не способен разобраться, то чем я отличаюсь от поклонников &lt;a href=&quot;http://lurkmore.to/%D0%9A%D1%83%D0%BB%D1%8C%D1%82_%D0%BA%D0%B0%D1%80%D0%B3%D0%BE&quot;&gt;карго-культа&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/2016-07-09-cargo-cult-lead.jpg&quot; alt=&quot;Cargo cult&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Я не понимаю Yesod и врядли когда-нибудь у меня будет пара свободных лет, чтобы разобраться, как он внутри устроен. Даже в разных Lisp-ах я никогда не видел столько метапрограммирования, столько макросов, как в Yesod. Но, в отличие от Lisp-овых макросов, те же квазицитаты Template Haskell устроены очень сложно, их трудно писать и еще труднее понимать. Если в Yesod что-нибудь пойдет не так, как ожидается, – смогу я сам всё починить, или буду годами ждать чужих багфиксов?&lt;/p&gt;

&lt;p&gt;Помимо метапрограммирования, Yesod использует множество хитрых расширений языка, с которыми тоже нужно разбираться. Или не разбираться – и тогда не понимать, как работает даже ваша собственная программа.&lt;/p&gt;

&lt;p&gt;Yesod, как и любой фреймворк, накрепко привязан к целому ряду решений, от которых сложно отказаться. Этот и Persistent для доступа к БД, и Shakespearean Templates для фронтенда, и многое другое. То, что Yesod “толстоват”, – это, конечно, проблема почти всех фреймворков. Но разобрать его на составляющие и использовать только то, что нужно, – задача не из простых.&lt;/p&gt;

&lt;p&gt;И при том, что в Yesod много готовых решений для типовых задач, там иногда нету самых простых вещей. Например, в Yesod нечем организовать сессию в памяти. Вы можете хранить сессию на клиенте, и, если этого достаточно, то всё ОК. Но вы не сможете положить в сессию большой граф объектов, который дорого вычислять на каждый запрос. Можно, конечно, организовать кэширование, привязанное к id пользователя, но это уже – велосипедостроение, а причина – в отсутсвии сессии в памяти.&lt;/p&gt;

&lt;p&gt;Проблемы Servant примерное такие же: сложное внутреннее устройство, да еще и общая бедность фреймворка. Нечем сделать сессию, нечем сделать нормальную аутентификацию, сложность стектрейсов и т.д.&lt;/p&gt;

&lt;p&gt;Я лично обходился связкой из рутера &lt;a href=&quot;https://github.com/scotty-web/scotty&quot;&gt;Scotty&lt;/a&gt;, Persistent-а для БД и aeson-а для общения с внешним миром. Не густо, как видите.&lt;/p&gt;

&lt;p&gt;Надо сказать, что в Haskell вообще очень медленно проникают технологии из мейнстрима.&lt;/p&gt;

&lt;h5 id=&quot;haskell-----&quot;&gt;В Haskell нет нормального доступа к БД&lt;/h5&gt;

&lt;p&gt;Есть, конечно, Persistent или mysql-simple / postgresql-simple и многое другое, в том числе – даже для NoSQL баз. И всё это совершенно неюзабельно. Ну вот, например, есть у вас сущность Cat, у неё есть свойства – id, head, tail. Представим себе веб-сервис, который создаёт котиков, передавая нам JSON примерно такого вида: {“head”: “white”, “tail”: “black”}. Пока что всё ОК. А теперь нам нужно его проапдейтить, и мы присылаем еще и его ID: {“id”: 17, “head”: “white”, “tail”: “black”}. Вот здесь уже начнутся проблемы. Даже если у нас и есть сущность вида&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Cat&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tail&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;всё равно мы не можем передать её в Persistent для изменения существующей записи. Проблема в том, что Persistent использует типизированные id сущностей, и поэтому их нельзя объединять в один тип данных. CatID – отдельно, Cat – отдельно. На UI – наоборот, это вполне себе цельная сущность, и её неудобно посылать по частям. Единственный правильный выход здесь – создавать тип данных Cat отдельно для UI и отдельно для Persistent, что приводит к значительному дублированию кода.&lt;/p&gt;

&lt;p&gt;Про *-simple даже говорить не буду, для любого типа данных, у которых больше двух-трёх полей эти библиотеки использовать неудобно.&lt;/p&gt;

&lt;h5 id=&quot;haskell-------&quot;&gt;Haskell – не для мейнстримных задач&lt;/h5&gt;

&lt;p&gt;Самая моя большая претензия к Haskell – он решает не те задачи. Когда пишешь на Haskell основное внимание сосредотачиваешь на построении правильной модели данных, на выявление всех нужных типов данных и поиск различных закономерностей на этих типах.&lt;/p&gt;

&lt;p&gt;В противовес этому мои ежедневные задачи – это что-то прочитать из HTTP-запроса, что-то записать в БД, что-то где-то вычислить и записать в файл. Мои типовые задачи не имеют ничего общего с построением полной, корректной модели предметной области и отображением её на теорию категорий. Ей-богу, мне всё равно, если вдруг в моих данных случайно обнаружится возможность свёртки, и я смогу реализовать Monoid. Мне почти всегда без разницы, что я смогу применить функцию ко всем составным частям моих данных и реализовать Functor или даже Applicative Functor. Моя задача – взять из HttpServletRequest какую-нибудь фигню, провалидировать и положить её в БД. Я хочу сделать это максимально простым и наглядным способом.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;В Haskell программист большую часть времени тратит на разработку красивой, корректной, стройной, “математичной” модели предметной области. И именно поэтому, если всё получилось хорошо, исходник на Haskell выглядит так красиво, стройно и “математично”. Сколько на это тратится времени и решает ли эта программа какую-нибудь задачу – не имеет значения.&lt;/p&gt;

&lt;p&gt;Конечно, мне нравится Haskell, ведь программы на нём получаются и корректные, красивые. Но за такую роскошь приходится платить непомерную цену времени.&lt;/p&gt;

&lt;h3 id=&quot;clojure&quot;&gt;Назад к Clojure&lt;/h3&gt;

&lt;p&gt;Когда ко мне пришел новый проект, в котором нужно было связать сразу несколько технологий, я и сам не заметил, как сделал всё на Clojure. Я совершенно не собирался использовать его как основной язык проекта. Просто пока экспериментируешь в REPL программа пишется сама собой, в конце остаётся всего лишь более-менее нормально всё оформить, завернуть в Component и Compojure, добавить БД – и готово!&lt;/p&gt;

&lt;p&gt;В отличие от Haskell, Clojure очень сильно направлен на практику. Здесь есть все нужные фреймворки и библиотеки, есть средства организации кода, такие как &lt;a href=&quot;https://github.com/stuartsierra/component&quot;&gt;Component&lt;/a&gt; и &lt;a href=&quot;https://github.com/tolitius/mount&quot;&gt;Mount&lt;/a&gt;, есть сервер приложений &lt;a href=&quot;http://immutant.org/&quot;&gt;Immutant&lt;/a&gt;, очень удобный в использовании рутер &lt;a href=&quot;https://github.com/weavejester/compojure&quot;&gt;Compojure&lt;/a&gt;, целый ворох самых разных библиотек для доступа к данным.&lt;/p&gt;

&lt;p&gt;Но самое главное: при работе с Clojure сосредотачиваешься именно на выполнении задачи.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;Самое кардинальное отличие Clojure от Haskell в том, что Haskell заставляет создавать отдельные типы данных для всего подряд. Clojure, наоборот, предлагает использовать существующие типы данных (список, вектор, отображение) и не заморачиваться.&lt;/p&gt;

&lt;p&gt;А как же рефакторинг? Ведь правильная модель данных здорово упрощает рефакторинг, в Clojure рефакторинг гораздо сложнее!&lt;/p&gt;

&lt;p&gt;Горькая правда в том, что большинство моего кода просто не доживает до рефакторинга. Мне нужно решение задачи здесь и сейчас, потому что завтра этой задачи может и не быть вовсе. И далеко не факт, что написанный даже на Haskell код мне когда-нибудь придется рефакторить.&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;Напоследок&lt;/h3&gt;

&lt;p&gt;После двух лет изучения Haskell я сильно разочарован. С другой стороны, конечно, я понимаю, что применил Haskell не в той области, для которой он предназначен.&lt;/p&gt;

&lt;p&gt;Вот мой основной вывод, к которму я пришел за эти два года: &lt;em&gt;не используйте Haskell в веб-разработке&lt;/em&gt;.&lt;/p&gt;

</description>
        <pubDate>Sat, 09 Jul 2016 00:00:00 +0300</pubDate>
        <link>http://clojure.by/articles/2016-07/why-not-haskell</link>
        <guid isPermaLink="true">http://clojure.by/articles/2016-07/why-not-haskell</guid>
        
        <category>haskell</category>
        
        
        <category>разработка</category>
        
      </item>
    
      <item>
        <title>Top-down разработка с Midje</title>
        <description>&lt;h3 id=&quot;wishful-thinking&quot;&gt;Wishful thinking&lt;/h3&gt;

&lt;p&gt;В документации по Midje есть вводная &lt;a href=&quot;https://github.com/marick/Midje/wiki/The-idea-behind-top-down-development&quot;&gt;статья&lt;/a&gt; о top-down development. Именно в ней показывается, что библиотека Midje подходит для разработки на Clojure как нельзя лучше.&lt;/p&gt;

&lt;p&gt;Идею wishful thinking предложили в &lt;a href=&quot;#book1&quot;&gt;[1]&lt;/a&gt; уже несколько десятилетий назад, в подробностях алгоритм разработки в стиле wishful thinking можно найти в &lt;a href=&quot;#book2&quot;&gt;[2]&lt;/a&gt;. Смысл идеи состоит в следующем. Предположим, нам необходимо решить какую-то задачу в некоторой предметной области. Традиционный подход состоит в том, чтобы выполнить декомпозицию задачи на подзадачи, а те – на другие подзадачи до тех пор, пока все подзадачи не станут досаточно простыми для реализации. Wishful thinking идет немного иным путем. Мы представляем, что уже есть некоторый API или предметно-ориентированный язык, моделирующий предметную область. И, представив, что этот API уже есть, решаем с его помощью задачу. Затем – реализуем все несуществующие функции этого API.&lt;/p&gt;

&lt;p&gt;Midje позволяет смоделировать этот несуществующий API и отложить его реализацию на самый последний этап разработки. Например, для реализации &lt;em&gt;some-func&lt;/em&gt; нам необходимы функции из несуществующего API: &lt;em&gt;api-func1&lt;/em&gt; и &lt;em&gt;api-func2&lt;/em&gt;.&lt;/p&gt;

&lt;p class=&quot;notice&quot;&gt;&lt;em&gt;На заметку:&lt;/em&gt; указанные функции могут быть не реализованы, но объявить их всё же нужно.&lt;/p&gt;

&lt;p&gt;Мы пишем тело &lt;em&gt;some-func&lt;/em&gt; так, будто &lt;em&gt;api-func1&lt;/em&gt; и &lt;em&gt;api-func2&lt;/em&gt; уже готовы, а затем пишем такой тест:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;facts&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;факты о функции &#39;some-func&#39;&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;fact&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&#39;some-func&#39; работает на несуществующем API&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    
     &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;some-func&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;arg2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

     &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;provided&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
         &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;api-func1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
         &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;api-func2&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;arg2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Обратите внимание на секцию &lt;em&gt;provided&lt;/em&gt;. Именно там мы определяем, как должны вести себя нереализованные &lt;em&gt;api-func1&lt;/em&gt; и &lt;em&gt;api-func2&lt;/em&gt;. Мы указываем, на каких аргументах вызываются эти функции и что они должны вернуть.&lt;/p&gt;

&lt;p&gt;Таким образом, мы можем вначале реализовать &lt;em&gt;some-func&lt;/em&gt;, и только потом – &lt;em&gt;api-func1&lt;/em&gt; и &lt;em&gt;api-func2&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;Фиктивные функции и значения&lt;/h3&gt;

&lt;p&gt;Показанный выше способ определения фиктивных функций работает в точности, как известный Java-фреймворк &lt;a href=&quot;http://mockito.org/&quot;&gt;Mockito&lt;/a&gt;. Но, помимо фиктивных функций Midje позволяет подставлять и фиктивные значения.&lt;/p&gt;

&lt;p&gt;В примере выше указаны нормальные значения, которые передаются в функции и получаются из них. Но, если неважны конкретные значения, передаваемые в API, можно писать следующим образом.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;facts&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;факты о функции &#39;some-func&#39;&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;fact&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&#39;some-func&#39; работает на несуществующем API&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    
     &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;some-func&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;..ARG2..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;..RESULT..&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

     &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;provided&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
         &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;api-func1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;anything&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
         &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;api-func2&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;..ARG2..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;..RESULT..&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Здесь &lt;em&gt;anything&lt;/em&gt; означает любой, неважно какой аргумент. &lt;em&gt;..ARG2..&lt;/em&gt; и &lt;em&gt;..RESULT..&lt;/em&gt; – метазначения. Их нужно использовать тогда, когда не важно содержимое, а важно только, чтобы оно было одинаковым везде, где используется одинаковое название метазначения.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;Некоторые особенности&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Midje предлагает очень удобный механизм &lt;a href=&quot;https://github.com/marick/Midje/wiki/Autotest&quot;&gt;автотестов&lt;/a&gt;. В REPL нужно сделать следующее:&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;midje.repl&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;no&quot;&gt;:refer&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;autotest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]])&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;autotest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Будет запущена асинхронная функция, которая отслеживает изменение исходных файлов и перезапускать все тесты, на которые влияют изменения.&lt;/p&gt;

&lt;p&gt;Особенность здесь вот какая: автотесты работают не всегда предсказуемо, если “нахимичить” с переопределениями var-ов. Лечение здесь одно: перезагрузка всех “сломанных” неймспейсов либо использовать &lt;em&gt;lein midje&lt;/em&gt; из консоли.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Нетривиальной задачей является тестирование макросов, если их нужно поместить в секцию &lt;em&gt;provided&lt;/em&gt;. Дело в том, что Midje не принимает макросы в &lt;em&gt;provided&lt;/em&gt;. Поэтому, единственный способ – это раскрыть макрос macroexpand-ом и подставить в &lt;em&gt;provided&lt;/em&gt; тело макроса. Так, например, обычный &lt;em&gt;(taoensso.timbre/debug “hello”)&lt;/em&gt; в секции &lt;em&gt;provided&lt;/em&gt; будет выглядеть так: &lt;em&gt;(taoensso.timbre/-log! anything anything anything anything anything anything anything anything anything anything)&lt;/em&gt;. К сожалению, Midje не позволяет “сократить” все десять anything до какого-нибудь одного параметра.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Если необходимо протестировать асинхронную функцию, то следует воспользоваться макросом &lt;a href=&quot;http://clojuredocs.org/clojure.core/with-redefs&quot;&gt;with-redefs&lt;/a&gt;, чтобы переопределить её на что-то синхронное. Макрос &lt;em&gt;with-redefs&lt;/em&gt; не переопределяет другие макросы, поэтому и здесь нужно раскрывать их macroexpand-ом:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;with-redefs&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;future-call&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Точно также можно “нейтрализовать” log-и, чтобы они не отображались в выводе из тестов.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;with-redefs&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log/-log!&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
   &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;log/debug&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;section-2&quot;&gt;Выводы&lt;/h3&gt;

&lt;p&gt;Midje отлично дополняет REPL-ориентированный подход Clojure. Если необходимо на скорую руку сделать черновик функционала, чтобы приблизительно представить возможную архитектуру, Midje предоставляет возможность использовать фиктивные функции и значения.&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;Литература&lt;/h3&gt;

&lt;div id=&quot;book1&quot;&gt;1. Абельсон Х., Сассман Дж. 2.1 Введение в абстракцию данных. В кн.: Структура и интерпретация компьютерных программ, Москва, Добросвет, 2010, с.93.&lt;/div&gt;
&lt;div id=&quot;book2&quot;&gt;2. Freeman S., Pryce N. Support for TDD with Mock Objects. In: Growing Object-Oriented Software, Guided by Tests. Location: Addison-Wesley, 2010, pp. 19-20.&lt;/div&gt;
</description>
        <pubDate>Sat, 02 Jul 2016 00:00:00 +0300</pubDate>
        <link>http://clojure.by/articles/2016-07/midje-top-down</link>
        <guid isPermaLink="true">http://clojure.by/articles/2016-07/midje-top-down</guid>
        
        <category>testing</category>
        
        <category>midje</category>
        
        
        <category>разработка</category>
        
      </item>
    
      <item>
        <title>Запуск Clojure Blog</title>
        <description>&lt;p&gt;Пару лет назад, будучи увлеченным евангелистом языка Clojure, я вел блог о самом языке Clojure, видео курс по Emacs Lisp, онлайн курсы по разработке веб-приложений на Clojure. Настало время вернуть всё, как было :-)&lt;/p&gt;

&lt;p&gt;Здесь я собираюсь писать статьи о языке Clojure, Emacs и Emacs Lisp. Все материалы курсов Никита Прокопов выложил на &lt;a href=&quot;http://clojurecourse.by&quot;&gt;ClojureCourse.by&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 30 Jun 2016 00:00:00 +0300</pubDate>
        <link>http://clojure.by/articles/2016-06/clojure-blog</link>
        <guid isPermaLink="true">http://clojure.by/articles/2016-06/clojure-blog</guid>
        
        
        <category>общее</category>
        
      </item>
    
  </channel>
</rss>
